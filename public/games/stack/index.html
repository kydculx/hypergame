<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stack Tower - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
        }

        #score {
            font-size: 48px;
            font-weight: bold;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        button {
            background: #646cff;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Your Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (!this.ctx) {
                    try {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) this.ctx = new AudioContextClass();
                    } catch (e) { }
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            }
            playNote(freq, type, duration, volume) {
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                if (Array.isArray(freq)) {
                    osc.frequency.setValueAtTime(freq[0], this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq[1], this.ctx.currentTime + duration);
                } else {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                }
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        const BOX_HEIGHT = 1, INITIAL_WIDTH = 3, INITIAL_DEPTH = 3;
        let scene, camera, renderer, activeBlock = null;
        let stack = [], debris = [], direction = 'x', speed = 0.15, gameState = 'START', score = 0;
        let targetCameraY = 10, targetCameraZoom = 1, currentCameraZoom = 1;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0b2e);
            scene.fog = new THREE.FogExp2(0x1a0b2e, 0.04);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(10, 20, 10);
            scene.add(dl);

            camera = new THREE.OrthographicCamera(-10 * (window.innerWidth / window.innerHeight), 10 * (window.innerWidth / window.innerHeight), 10, -10, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            addBlock(0, 0, 0, INITIAL_WIDTH, INITIAL_DEPTH, false);
            gameState = 'START';
            resize();
            animate();
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function addBlock(x, y, z, width, depth, isActive) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, BOX_HEIGHT, depth), new THREE.MeshStandardMaterial({ color: new THREE.Color(`hsl(${score * 10 + 200}, 70%, 60%)`) }));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            const block = { mesh, width, depth };
            if (isActive) activeBlock = block; else stack.push(block);
            return block;
        }

        function handleAction() {
            audio.init();
            if (gameState === 'OVER') return;
            if (gameState === 'START') { gameState = 'PLAYING'; startNewRound(); return; }

            const top = stack[stack.length - 1];
            const diff = activeBlock.mesh.position[direction] - top.mesh.position[direction];
            const overlap = activeBlock[direction === 'x' ? 'width' : 'depth'] - Math.abs(diff);

            if (overlap <= 0) { gameOver(); return; }

            const isPerfect = Math.abs(diff) < 0.15;
            audio.playNote(220 + score * 20, isPerfect ? 'sine' : 'triangle', 0.1, 0.3);

            const newW = direction === 'x' ? overlap : activeBlock.width;
            const newD = direction === 'z' ? overlap : activeBlock.depth;
            const newX = direction === 'x' ? top.mesh.position.x + diff / 2 : activeBlock.mesh.position.x;
            const newZ = direction === 'z' ? top.mesh.position.z + diff / 2 : activeBlock.mesh.position.z;

            activeBlock.mesh.geometry.dispose();
            activeBlock.mesh.geometry = new THREE.BoxGeometry(newW, BOX_HEIGHT, newD);
            activeBlock.mesh.position.x = newX;
            activeBlock.mesh.position.z = newZ;
            activeBlock.width = newW;
            activeBlock.depth = newD;

            stack.push(activeBlock);
            score++;
            document.getElementById('score').textContent = score;
            window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');
            speed = Math.abs(speed) + 0.002;
            startNewRound();
        }

        function startNewRound() {
            const top = stack[stack.length - 1];
            direction = direction === 'x' ? 'z' : 'x';
            addBlock(direction === 'x' ? -10 : top.mesh.position.x, stack.length * BOX_HEIGHT, direction === 'z' ? -10 : top.mesh.position.z, top.width, top.depth, true);
            targetCameraY = stack.length * BOX_HEIGHT + 10;
        }

        function update() {
            if (gameState === 'PLAYING' && activeBlock) {
                activeBlock.mesh.position[direction] += speed;
                if (Math.abs(activeBlock.mesh.position[direction]) > 10) gameOver();
            }
            camera.position.y += (targetCameraY - camera.position.y) * 0.1;
            currentCameraZoom += (targetCameraZoom - currentCameraZoom) * 0.1;
            camera.zoom = currentCameraZoom;
            camera.updateProjectionMatrix();
        }

        function render() { renderer.render(scene, camera); }
        function animate() { requestAnimationFrame(animate); update(); render(); }
        function resize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -10 * aspect; camera.right = 10 * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function gameOver() {
            if (gameState === 'OVER') return; gameState = 'OVER';
            targetCameraZoom = Math.max(0.2, 10 / (stack.length * BOX_HEIGHT + 10));
            targetCameraY = (stack.length * BOX_HEIGHT) / 2;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            audio.playNote([440, 110], 'sawtooth', 0.5, 0.3);
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        window.addEventListener('pointerdown', handleAction);
        window.addEventListener('keydown', e => { if (e.code === 'Space') handleAction(); });
        window.addEventListener('resize', resize);
        init();
    </script>
</body>

</html>