<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stack Tower - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
        }

        #score {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #instructions {
            font-size: 18px;
            opacity: 0.8;
            margin-top: 10px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            color: white;
            text-align: center;
            display: none;
            pointer-events: auto;
        }

        button {
            background: #646cff;
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            background: #535bf2;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
        <div id="instructions">Click or Space to Stack</div>
    </div>

    <div id="game-over">
        <h1 style="margin-top:0">GAME OVER</h1>
        <p>Your Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">START</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Constants
        const BOX_HEIGHT = 1;
        const INITIAL_WIDTH = 3;
        const INITIAL_DEPTH = 3;

        let scene, camera, renderer;
        let stack = [];
        let debris = [];
        let activeBlock = null;
        let direction = 'x';
        let speed = 0.15;
        let gameState = 'START'; // START, PLAYING, OVER
        let score = 0;

        // Audio Manager
        class AudioManager {
            constructor() {
                this.ctx = null;
            }
            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            playNote(freq, type, duration, volume) {
                if (!this.ctx) return;
                if (this.ctx.state === 'suspended') this.ctx.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;

                // Frequency slide for game over
                if (Array.isArray(freq)) {
                    osc.frequency.setValueAtTime(freq[0], this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq[1], this.ctx.currentTime + duration);
                } else {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                }

                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x242424);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 0);
            scene.add(dirLight);

            // Camera (Orthographic for that classic stack look)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 10;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Foundation
            addBlock(0, 0, 0, INITIAL_WIDTH, INITIAL_DEPTH, false);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', handleAction);
            window.addEventListener('keydown', (e) => { if (e.code === 'Space') handleAction(); });

            animate();

            // Notify platform
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function addBlock(x, y, z, width, depth, isActive) {
            const color = new THREE.Color(`hsl(${score * 10 + 200}, 70%, 60%)`);
            const geometry = new THREE.BoxGeometry(width, BOX_HEIGHT, depth);
            const material = new THREE.MeshStandardMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);

            const block = { mesh, width, depth };
            if (isActive) {
                activeBlock = block;
            } else {
                stack.push(block);
            }
            return block;
        }

        function handleAction() {
            audio.init();
            if (gameState === 'OVER') return;
            if (gameState === 'START') {
                gameState = 'PLAYING';
                startNewRound();
                return;
            }

            // Place Block
            const topBlock = stack[stack.length - 1];
            const diff = activeBlock.mesh.position[direction] - topBlock.mesh.position[direction];
            const dimension = direction === 'x' ? 'width' : 'depth';
            const overlap = activeBlock[dimension] - Math.abs(diff);

            if (overlap <= 0) {
                gameOver();
                return;
            }

            // Sound feedback
            const isPerfect = Math.abs(diff) < 0.15;
            const baseFreq = 220 + (score * 20);
            if (isPerfect) {
                audio.playNote(baseFreq * 1.5, 'sine', 0.2, 0.3);
            } else {
                audio.playNote(baseFreq, 'triangle', 0.1, 0.3);
            }

            // Slice block logic
            const newWidth = direction === 'x' ? overlap : activeBlock.width;
            const newDepth = direction === 'z' ? overlap : activeBlock.depth;
            const newX = direction === 'x' ? topBlock.mesh.position.x + diff / 2 : activeBlock.mesh.position.x;
            const newZ = direction === 'z' ? topBlock.mesh.position.z + diff / 2 : activeBlock.mesh.position.z;

            // Update active block to represent the overlap
            activeBlock.mesh.scale[direction] = overlap / activeBlock[dimension];
            activeBlock.mesh.position[direction] = newX;
            if (direction === 'z') activeBlock.mesh.position.z = newZ;

            activeBlock.width = newWidth;
            activeBlock.depth = newDepth;

            // Add debris (falling part)
            const debrisWidth = direction === 'x' ? activeBlock[dimension] - overlap : activeBlock.width;
            const debrisDepth = direction === 'z' ? activeBlock[dimension] - overlap : activeBlock.depth;
            const debrisX = direction === 'x'
                ? (diff > 0 ? newX + newWidth / 2 + debrisWidth / 2 : newX - newWidth / 2 - debrisWidth / 2)
                : activeBlock.mesh.position.x;
            const debrisZ = direction === 'z'
                ? (diff > 0 ? newZ + newDepth / 2 + debrisDepth / 2 : newZ - newDepth / 2 - debrisDepth / 2)
                : activeBlock.mesh.position.z;

            addDebris(debrisX, activeBlock.mesh.position.y, debrisZ, debrisWidth, debrisDepth, activeBlock.mesh.material.color);

            stack.push(activeBlock);
            score++;
            document.getElementById('score').textContent = score;
            window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');

            // Increase speed slightly
            speed += 0.002;

            startNewRound();
        }

        function startNewRound() {
            const topBlock = stack[stack.length - 1];
            direction = direction === 'x' ? 'z' : 'x';

            const x = direction === 'x' ? -10 : topBlock.mesh.position.x;
            const z = direction === 'z' ? -10 : topBlock.mesh.position.z;
            const y = stack.length * BOX_HEIGHT;

            addBlock(x, y, z, topBlock.width, topBlock.depth, true);

            // Move camera up
            const targetY = stack.length + 10;
            new TWEEN_Simple(camera.position, { y: targetY }, 500);
        }

        function gameOver() {
            gameState = 'OVER';
            audio.playNote([440, 110], 'sawtooth', 0.5, 0.3);
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        function restartGame() {
            location.reload();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 10;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function addDebris(x, y, z, width, depth, color) {
            const geometry = new THREE.BoxGeometry(width, BOX_HEIGHT, depth);
            const material = new THREE.MeshStandardMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            debris.push({ mesh, velocity: { y: 0, r: (Math.random() - 0.5) * 0.1 } });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'PLAYING' && activeBlock) {
                activeBlock.mesh.position[direction] += speed;
                if (Math.abs(activeBlock.mesh.position[direction]) > 10) {
                    speed *= -1;
                }
            }

            // Debris physics
            for (let i = debris.length - 1; i >= 0; i--) {
                const d = debris[i];
                d.velocity.y -= 0.02; // Gravity
                d.mesh.position.y += d.velocity.y;
                d.mesh.rotation.x += d.velocity.r;
                d.mesh.rotation.z += d.velocity.r;

                if (d.mesh.position.y < -10) {
                    scene.remove(d.mesh);
                    debris.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Minimal TWEEN helper for camera
        function TWEEN_Simple(obj, target, duration) {
            const start = { ...obj };
            const startTime = performance.now();

            function update() {
                const now = performance.now();
                const progress = Math.min((now - startTime) / duration, 1);
                for (const key in target) {
                    obj[key] = start[key] + (target[key] - start[key]) * progress;
                }
                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }
    </script>
</body>

</html>