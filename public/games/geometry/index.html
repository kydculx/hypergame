<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geometry Dash - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #2c3e50;
            font-family: sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            font-size: 64px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
            z-index: 20;
            min-width: 200px;
            pointer-events: auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        h1 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        p {
            color: #666;
            margin: 0 0 20px 0;
            font-size: 16px;
        }

        #final-score {
            color: #e74c3c;
            font-weight: bold;
            font-size: 24px;
        }

        button {
            background: #e74c3c;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #c0392b;
            margin-top: 0;
        }

        button:hover {
            background: #c0392b;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Constants ---
        const PLAYER_SIZE = 1;
        const JUMP_FORCE = 0.36;
        const GRAVITY = 0.016;
        const GAME_SPEED_BASE = 0.18;

        const COLORS = {
            bg: 0x1a1a2e,
            player: 0xf1c40f,
            ground: 0x16213e,
            spike: 0xe94560,
            block: 0x0f3460
        };

        let scene, camera, renderer;
        let player, ground;
        let obstacles = [];
        let particles = [];
        let parallaxObjects = [];
        let score = 0;
        let gameState = 'START';

        // Physics
        let velocityY = 0;
        let isGrounded = true;
        let currentSpeed = GAME_SPEED_BASE;
        let rotationZ = 0;
        let groundY = -2;

        // Audio Manager
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (!this.ctx) {
                    try {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) this.ctx = new AudioContextClass();
                    } catch (e) {
                        console.warn("AudioContext failed:", e);
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
            }
            playNote(freq, type, duration = 0.1, volume = 0.1) {
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.value = freq;
                osc.type = type;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                gain.gain.value = volume;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.00001, this.ctx.currentTime + duration);
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.bg);
            scene.fog = new THREE.Fog(COLORS.bg, 10, 30);

            // Side View Orthographic
            const aspect = window.innerWidth / window.innerHeight;
            const d = 10;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 100);
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Light
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(5, 10, 10);
            scene.add(dl);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            // Ground
            const groundGeo = new THREE.BoxGeometry(100, 5, 10);
            const groundMat = new THREE.MeshLambertMaterial({ color: COLORS.ground });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.position.set(0, groundY - 2.5, 0);
            scene.add(ground);

            // Player
            player = new THREE.Mesh(
                new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE),
                new THREE.MeshPhongMaterial({ color: COLORS.player, emissive: 0xaa8800 })
            );
            player.position.set(-6, groundY + PLAYER_SIZE / 2, 0);
            scene.add(player);

            // Parallax
            for (let i = 0; i < 15; i++) {
                const size = Math.random() * 3 + 1;
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05 })
                );
                mesh.position.set((Math.random() - 0.5) * 80, Math.random() * 20 - 5, -10 - Math.random() * 20);
                mesh.userData = { speed: Math.random() * 0.8 + 0.2 };
                scene.add(mesh);
                parallaxObjects.push(mesh);
            }

            spawnObstacle(10);
            gameState = 'PLAYING';
            resize();
            animate();
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function resize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 10;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            player.position.x = Math.max(-6, camera.left + 3);
        }

        function jump() {
            if (gameState !== 'PLAYING') return;
            if (isGrounded) {
                velocityY = JUMP_FORCE;
                isGrounded = false;
                audio.playNote(400, 'sine');
            }
        }

        function spawnObstacle(xOffset) {
            const type = Math.random() < 0.7 ? 'SPIKE' : 'BLOCK';
            let mesh;
            if (type === 'SPIKE') {
                mesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 4), new THREE.MeshLambertMaterial({ color: COLORS.spike }));
                mesh.position.set(xOffset, groundY + 0.5, 0);
                mesh.userData = { width: 0.5, height: 0.5 };
            } else {
                const height = Math.random() < 0.5 ? 1 : 1.5;
                mesh = new THREE.Mesh(new THREE.BoxGeometry(1, height, 1), new THREE.MeshLambertMaterial({ color: COLORS.block }));
                mesh.position.set(xOffset, groundY + height / 2, 0);
                mesh.userData = { width: 0.5, height: height / 2 };
            }
            scene.add(mesh);
            obstacles.push(mesh);
        }

        function spawnParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                const size = Math.random() * 0.3 + 0.1;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({ color }));
                mesh.position.set(x + (Math.random() - 0.5), y + (Math.random() - 0.5), 0);
                scene.add(mesh);
                particles.push({ mesh, vx: (Math.random() - 0.5) * 0.3, vy: Math.random() * 0.3, life: 1.0 });
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;

            velocityY -= GRAVITY;
            player.position.y += velocityY;

            if (player.position.y <= groundY + PLAYER_SIZE / 2) {
                if (!isGrounded) spawnParticles(player.position.x, groundY + 0.5, COLORS.ground, 10);
                player.position.y = groundY + PLAYER_SIZE / 2;
                velocityY = 0;
                isGrounded = true;
                const nearest90 = Math.round(player.rotation.z / (Math.PI / 2)) * (Math.PI / 2);
                player.rotation.z += (nearest90 - player.rotation.z) * 0.25;
            } else {
                player.rotation.z -= 0.15;
            }

            score += currentSpeed * 10;
            document.getElementById('score').textContent = Math.floor(score);

            if (obstacles.length > 0) {
                const lastObs = obstacles[obstacles.length - 1];
                if (lastObs.position.x < 15) {
                    const progress = Math.min(1.0, score / 3000);
                    const gap = (15 - (9 * progress)) + Math.random() * (10 - (5 * progress));
                    spawnObstacle(lastObs.position.x + gap);
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.position.x -= currentSpeed;
                if (obs.position.x < camera.left - 5) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    continue;
                }
                const pHalf = PLAYER_SIZE / 2 * 0.8;
                if (Math.abs(player.position.x - obs.position.x) < pHalf + obs.userData.width &&
                    Math.abs(player.position.y - obs.position.y) < pHalf + obs.userData.height) {
                    gameOver();
                }
            }

            currentSpeed += 0.00005;
            parallaxObjects.forEach(p => {
                p.position.x -= currentSpeed * p.userData.speed;
                if (p.position.x < camera.left - 10) p.position.x = camera.right + 10;
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.x += p.vx;
                p.mesh.position.y += p.vy;
                p.mesh.scale.multiplyScalar(0.9);
                p.life -= 0.05;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function render() {
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            render();
        }

        function gameOver() {
            gameState = 'OVER';
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = Math.floor(score);
            audio.playNote(100, 'sawtooth', 0.5, 0.3);
            spawnParticles(player.position.x, player.position.y, COLORS.player, 20);
            player.visible = false;
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score: Math.floor(score) } }, '*');
        }

        function restartGame() {
            location.reload();
        }

        const jumpHandler = (e) => {
            if (e && e.cancelable) e.preventDefault();
            audio.init();
            jump();
        };
        window.addEventListener('pointerdown', jumpHandler, { passive: false });
        window.addEventListener('keydown', e => { if (e.code === 'Space') jumpHandler(e); });
        window.addEventListener('resize', resize);

        init();
    </script>
</body>

</html>