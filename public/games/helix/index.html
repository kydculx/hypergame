<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helix Jump - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #222;
            font-family: sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            font-size: 64px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
            z-index: 20;
            min-width: 200px;
            pointer-events: auto;
        }

        h1 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        p {
            color: #666;
            margin: 0 0 20px 0;
            font-size: 16px;
        }

        #final-score {
            color: #e74c3c;
            font-weight: bold;
            font-size: 24px;
        }

        button {
            background: #e74c3c;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #c0392b;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (!this.ctx) {
                    try {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) this.ctx = new AudioContextClass();
                    } catch (e) { }
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            }
            playNote(freq, type, duration = 0.1, volume = 0.1) {
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.value = freq;
                osc.type = type;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                gain.gain.value = volume;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.00001, this.ctx.currentTime + duration);
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        const BALL_RADIUS = 0.35, POLE_RADIUS = 1.2, PLATFORM_WIDTH = 2, FLOOR_HEIGHT = 4, GRAVITY = 0.018, BOUNCE_FORCE = 0.35, GAP_SIZE = 1.2;
        let scene, camera, renderer, ball, pole;
        let platforms = [], splats = [], score = 0, gameState = 'START', comboCount = 0;
        let ballY = 2, ballDy = 0, lastX, isDrag = false;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 10, 30);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 1, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(5, 10, 5);
            scene.add(dl);

            pole = new THREE.Group();
            scene.add(pole);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(POLE_RADIUS, POLE_RADIUS, 200, 32), new THREE.MeshLambertMaterial({ color: 0xffffff }));
            cyl.position.y = -90;
            pole.add(cyl);

            for (let i = 0; i < 30; i++) createFloor(i);

            ball = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff0055 }));
            ball.position.set(0, ballY, POLE_RADIUS + PLATFORM_WIDTH / 2);
            scene.add(ball);

            gameState = 'PLAYING';
            resize();
            animate();
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function createFloor(index) {
            const y = -index * FLOOR_HEIGHT;
            const group = new THREE.Group();
            group.position.y = y;
            group.rotation.y = Math.random() * Math.PI * 2;
            group.userData = { passed: false };
            const shape = new THREE.Shape();
            shape.absarc(0, 0, POLE_RADIUS + PLATFORM_WIDTH, GAP_SIZE / 2, Math.PI * 2 - GAP_SIZE / 2, false);
            shape.absarc(0, 0, POLE_RADIUS, Math.PI * 2 - GAP_SIZE / 2, GAP_SIZE / 2, true);
            const isDanger = index > 0 && Math.random() < 0.3;
            const mat = new THREE.MeshLambertMaterial({ color: isDanger ? 0xff3300 : 0x00aaff });
            const mesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: false }), mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.userData = { isDanger };
            group.add(mesh);
            pole.add(group);
            platforms.push(group);
        }

        function createSplat(y) {
            const splat = new THREE.Mesh(new THREE.CircleGeometry(BALL_RADIUS * 1.5, 16), new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.8, depthWrite: false }));
            splat.rotation.x = -Math.PI / 2;
            const angle = -pole.rotation.y;
            splat.position.set(Math.sin(angle) * (POLE_RADIUS + PLATFORM_WIDTH / 2), y + 0.11, Math.cos(angle) * (POLE_RADIUS + PLATFORM_WIDTH / 2));
            pole.add(splat);
            splats.push(splat);
            if (splats.length > 20) pole.remove(splats.shift());
        }

        function update() {
            if (gameState !== 'PLAYING') return;
            ballDy -= GRAVITY;
            ballY += ballDy;
            const targetCamY = ballY + 4;
            camera.position.y += (targetCamY - camera.position.y) * 0.1;
            const prevY = ballY - ballDy;
            platforms.forEach(p => {
                const py = p.position.y;
                if (prevY - BALL_RADIUS >= py && ballY - BALL_RADIUS <= py && ballDy < 0) {
                    let relAngle = (-Math.PI / 2 - (pole.rotation.y + p.rotation.y)) % (Math.PI * 2);
                    if (relAngle < 0) relAngle += Math.PI * 2;
                    if (relAngle > GAP_SIZE / 2 && relAngle < Math.PI * 2 - GAP_SIZE / 2) {
                        if (p.children[0].userData.isDanger) { gameOver(); return; }
                        createSplat(py);
                        ballDy = BOUNCE_FORCE;
                        ballY = py + BALL_RADIUS;
                        audio.playNote(600, 'triangle');
                        comboCount = 0;
                    } else if (!p.userData.passed) {
                        p.userData.passed = true; score++; comboCount++;
                        document.getElementById('score').textContent = score;
                        audio.playNote(500 + comboCount * 100, 'sine');
                        window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');
                    }
                }
            });
            splats.forEach(s => s.material.opacity = Math.max(0, s.material.opacity - 0.005));
            ball.position.y = ballY;
            if (ballY < -120) gameOver();
        }

        function render() { renderer.render(scene, camera); }
        function animate() { requestAnimationFrame(animate); update(); render(); }
        function resize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function gameOver() {
            if (gameState === 'OVER') return; gameState = 'OVER';
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            audio.playNote(150, 'sawtooth');
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        window.addEventListener('pointerdown', e => { audio.init(); isDrag = true; lastX = e.clientX || (e.touches && e.touches[0].clientX); });
        window.addEventListener('pointerup', () => isDrag = false);
        window.addEventListener('pointermove', e => {
            if (!isDrag || gameState !== 'PLAYING') return;
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            pole.rotation.y += (x - lastX) * 0.01;
            lastX = x;
        }, { passive: false });
        window.addEventListener('resize', resize);
        init();
    </script>
</body>

</html>