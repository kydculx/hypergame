<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZigZag - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #a9cce3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            font-size: 64px;
            font-weight: 800;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
            color: #ffffff;
        }

        #instructions {
            font-size: 18px;
            opacity: 0.9;
            margin-top: 10px;
            color: #555;
            font-weight: 600;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 20;
            min-width: 200px;
        }

        h1 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        p {
            color: #666;
            margin: 0 0 20px 0;
            font-size: 16px;
        }

        #final-score {
            color: #e74c3c;
            font-weight: bold;
            font-size: 24px;
        }

        button {
            background: #3498db;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #2980b9;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        button:hover {
            background: #2980b9;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
        <div id="instructions">Tap to Switch Direction</div>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const PLATFORM_SIZE = 3;
        const BALL_RADIUS = 0.5;
        const BALL_SPEED_BASE = 0.15;
        const CAMERA_OFFSET = { x: 20, y: 20, z: 20 };
        const COLORS = {
            background: 0xa9cce3,
            ball: 0xe74c3c,
            platform: 0xe5e8e8, // Off-white
            platformHighlight: 0xffffff, // Pure white
            shadow: 0xd6eaf8,
            crystal: 0xf1c40f
        };

        let scene, camera, renderer;
        let ball;
        let platforms = [];
        let crystals = [];
        let clouds = [];
        let score = 0;
        let gameState = 'START'; // START, PLAYING, OVER
        let direction = 'x'; // 'x' or 'z'
        let speed = BALL_SPEED_BASE;
        let lastPlatformPos = { x: 0, y: 0, z: 0 };
        let frames = 0;
        let targetCameraPos = { x: 0, y: 0, z: 0 };
        let isGameOver = false;
        let isStarted = false;

        let scoreEl, instructionsEl, gameOverEl, finalScoreEl;

        // Audio System
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (!this.ctx) {
                    try {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) this.ctx = new AudioContextClass();
                    } catch (e) {
                        console.warn("AudioContext failed:", e);
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
            }
            playNote(freq, type, duration = 0.1, volume = 0.1) {
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.value = freq;
                osc.type = type;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.00001, this.ctx.currentTime + duration);
                osc.stop(this.ctx.currentTime + duration);
            }

            // Specific sound effects
            playSwitchSound() {
                this.init();
                if (!this.ctx) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }

            playCrystalSound() {
                this.init();
                if (!this.ctx) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.linearRampToValueAtTime(1760, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            }

            playGameOverSound() {
                this.init();
                if (!this.ctx) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }
        const audio = new AudioManager();

        init();
        audio.init(); // Pre-initialize context

        function init() {
            // Get UI elements
            scoreEl = document.getElementById('score');
            instructionsEl = document.getElementById('instructions');
            gameOverEl = document.getElementById('game-over');
            finalScoreEl = document.getElementById('final-score');

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.background);
            scene.fog = new THREE.Fog(COLORS.background, 20, 60);

            // Camera (Orthographic for Isometric view)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(CAMERA_OFFSET.x, CAMERA_OFFSET.y, CAMERA_OFFSET.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(20, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Init Game Objects
            initClouds();
            createBall();

            // Initial Platform Generation
            createPlatform(0, 0, 0);
            for (let i = 0; i < 20; i++) {
                spawnNextPlatform();
            }

            window.addEventListener('pointerdown', handleAction, { passive: false });
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') handleAction(e);
            });
            window.addEventListener('resize', resize);

            // Start Loop
            animate();

            // Notify Parent
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function createBall() {
            const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: COLORS.ball, shininess: 50 });
            ball = new THREE.Mesh(geometry, material);
            ball.position.set(0, BALL_RADIUS + PLATFORM_SIZE / 2, 0); // Sit on top of platform
            ball.castShadow = true;
            scene.add(ball);
        }

        function initClouds() {
            for (let i = 0; i < 60; i++) {
                const geo = new THREE.DodecahedronGeometry(Math.random() * 0.8 + 0.2, 1);
                const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, flatShading: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 120,
                    Math.random() * 30 - 15,
                    (Math.random() - 0.5) * 120
                );
                scene.add(mesh);
                clouds.push({ mesh, speed: Math.random() * 0.05 + 0.01 });
            }
        }

        function createPlatform(x, y, z) {
            const geometry = new THREE.BoxGeometry(PLATFORM_SIZE, PLATFORM_SIZE, PLATFORM_SIZE);
            const material = new THREE.MeshLambertMaterial({ color: COLORS.platform });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            platforms.push(mesh);
            lastPlatformPos = { x, y, z };

            // Decoration / Shadow block
            const shadowGeo = new THREE.BoxGeometry(PLATFORM_SIZE, PLATFORM_SIZE * 2, PLATFORM_SIZE);
            const shadowMat = new THREE.MeshBasicMaterial({ color: COLORS.shadow });
            const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
            shadowMesh.position.set(x, y - PLATFORM_SIZE * 1.5, z);
            scene.add(shadowMesh);
            mesh.userData.shadow = shadowMesh; // Link to remove later

            // Chance to spawn crystal (10%)
            if (Math.random() < 0.15 && frames > 5) {
                createCrystal(x, y + PLATFORM_SIZE / 2 + 1, z);
            }
        }

        function createCrystal(x, y, z) {
            const geometry = new THREE.OctahedronGeometry(0.6);
            const material = new THREE.MeshPhongMaterial({
                color: COLORS.crystal,
                emissive: 0x444400,
                shininess: 100
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            scene.add(mesh);
            crystals.push(mesh);
        }

        function spawnNextPlatform() {
            frames++;
            let isX = Math.random() > 0.5;

            // Force straight path for first 15 blocks to align with initial ball direction
            if (platforms.length < 15) {
                isX = true;
            }

            const newX = lastPlatformPos.x + (isX ? PLATFORM_SIZE : 0);
            const newZ = lastPlatformPos.z + (isX ? 0 : -PLATFORM_SIZE); // Move -Z (forward/right visually)

            createPlatform(newX, lastPlatformPos.y, newZ);
        }

        function handleAction(e) {
            if (e && e.cancelable) e.preventDefault();
            if (isGameOver) return;

            audio.init();
            if (gameState === 'START') {
                gameState = 'PLAYING';
                isStarted = true;
                instructionsEl.style.opacity = 0;
                // Give a small delay before first switch to prevent accidental double-tap start
                setTimeout(() => {
                    if (instructionsEl) {
                        instructionsEl.style.display = 'none';
                    }
                }, 500);
                return;
            }

            direction = direction === 'x' ? 'z' : 'x';
            audio.playSwitchSound();
        }

        function gameOver() {
            isGameOver = true;
            gameState = 'OVER';
            audio.playGameOverSound();
            gameOverEl.style.display = 'block';
            finalScoreEl.textContent = score;
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        function restartGame() {
            location.reload();
        }

        function resize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function update() {
            if (isGameOver || !isStarted) {
                // Continue cloud movement even if game is over
                clouds.forEach(c => {
                    c.mesh.position.x += c.speed;
                    // Simple reset for clouds, could be more sophisticated
                    if (c.mesh.position.x > ball.position.x + 60) c.mesh.position.x = ball.position.x - 60;
                });

                // Fall animation continue if game is over
                if (isGameOver && ball.position.y > -50) {
                    ball.position.y -= 0.5;
                    // Camera looks down slightly to watch fall
                    camera.position.y += (CAMERA_OFFSET.y + 10 - camera.position.y) * 0.05;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
    <!-- Google Ads Container -->
    <div id="ad-container"
        style="position: absolute; bottom: 0; left: 0; width: 100%; text-align: center; z-index: 100;">
        <script async
            src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX"
            crossorigin="anonymous"></script>
        <!-- Horizontal Banner -->
        <ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px"
            data-ad-client="ca-pub-XXXXXXXXXXXXXXXX" data-ad-slot="XXXXXXXXXX"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </div>
</body>

</html>