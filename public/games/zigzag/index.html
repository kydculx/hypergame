<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZigZag - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #a9cce3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            font-size: 64px;
            font-weight: 800;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
            color: #ffffff;
        }

        #instructions {
            font-size: 18px;
            opacity: 0.9;
            margin-top: 10px;
            color: #555;
            font-weight: 600;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 20;
            min-width: 200px;
        }

        h1 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        p {
            color: #666;
            margin: 0 0 20px 0;
            font-size: 16px;
        }

        #final-score {
            color: #e74c3c;
            font-weight: bold;
            font-size: 24px;
        }

        button {
            background: #3498db;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #2980b9;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        button:hover {
            background: #2980b9;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
        <div id="instructions">Tap to Switch Direction</div>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">RETRY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const PLATFORM_SIZE = 3;
        const BALL_RADIUS = 0.5;
        const BALL_SPEED_BASE = 0.15;
        const CAMERA_OFFSET = { x: 20, y: 20, z: 20 };
        const COLORS = {
            background: 0xa9cce3,
            ball: 0xe74c3c,
            platform: 0xe5e8e8, // Off-white
            platformHighlight: 0xffffff, // Pure white
            shadow: 0xd6eaf8,
            crystal: 0xf1c40f
        };

        let scene, camera, renderer;
        let ball;
        let platforms = [];
        let crystals = [];
        let clouds = [];
        let score = 0;
        let gameState = 'START'; // START, PLAYING, OVER
        let direction = 'x'; // 'x' or 'z'
        let speed = BALL_SPEED_BASE;
        let lastPlatformPos = { x: 0, y: 0, z: 0 };
        let frames = 0;
        let targetCameraPos = { x: 0, y: 0, z: 0 };

        // Audio System
        let audioCtx = null;
        function initAudio() {
            if (audioCtx) return;
            try {
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                if (AudioContextClass) audioCtx = new AudioContextClass();
            } catch (e) {
                console.warn("AudioContext failed:", e);
            }
        }
        function playTone(freq, type) {
            initAudio();
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.type = type;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
            osc.stop(audioCtx.currentTime + 0.1);
        }

        init();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'switch') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'crystal') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.linearRampToValueAtTime(1760, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'gameover') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.background);
            scene.fog = new THREE.Fog(COLORS.background, 20, 60);

            // Camera (Orthographic for Isometric view)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(CAMERA_OFFSET.x, CAMERA_OFFSET.y, CAMERA_OFFSET.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(20, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Init Game Objects
            initClouds();
            createBall();

            // Initial Platform Generation
            createPlatform(0, 0, 0);
            for (let i = 0; i < 20; i++) {
                spawnNextPlatform();
            }

            function handleInput(e) {
                if (e && e.cancelable) e.preventDefault();
                initAudio();
                if (gameState === 'START') {
                    gameState = 'PLAYING';
                    document.getElementById('instructions').style.display = 'none';
                    return;
                }
                if (gameState !== 'PLAYING') return;

                direction = direction === 'x' ? 'z' : 'x';
                playTone(400 + Math.random() * 100, 'sine');
            }

            const options = { passive: false };
            window.addEventListener('pointerdown', handleInput, options);
            window.addEventListener('touchstart', handleInput, options);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') handleInput(e);
            });

            // Start Loop
            animate();

            // Notify Parent
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function createBall() {
            const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: COLORS.ball, shininess: 50 });
            ball = new THREE.Mesh(geometry, material);
            ball.position.set(0, BALL_RADIUS + PLATFORM_SIZE / 2, 0); // Sit on top of platform
            ball.castShadow = true;
            scene.add(ball);
        }

        function initClouds() {
            for (let i = 0; i < 60; i++) {
                const geo = new THREE.DodecahedronGeometry(Math.random() * 0.8 + 0.2, 1);
                const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, flatShading: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 120,
                    Math.random() * 30 - 15,
                    (Math.random() - 0.5) * 120
                );
                scene.add(mesh);
                clouds.push({ mesh, speed: Math.random() * 0.05 + 0.01 });
            }
        }

        function createPlatform(x, y, z) {
            const geometry = new THREE.BoxGeometry(PLATFORM_SIZE, PLATFORM_SIZE, PLATFORM_SIZE);
            const material = new THREE.MeshLambertMaterial({ color: COLORS.platform });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            platforms.push(mesh);
            lastPlatformPos = { x, y, z };

            // Decoration / Shadow block
            const shadowGeo = new THREE.BoxGeometry(PLATFORM_SIZE, PLATFORM_SIZE * 2, PLATFORM_SIZE);
            const shadowMat = new THREE.MeshBasicMaterial({ color: COLORS.shadow });
            const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
            shadowMesh.position.set(x, y - PLATFORM_SIZE * 1.5, z);
            scene.add(shadowMesh);
            mesh.userData.shadow = shadowMesh; // Link to remove later

            // Chance to spawn crystal (10%)
            if (Math.random() < 0.15 && frames > 5) {
                createCrystal(x, y + PLATFORM_SIZE / 2 + 1, z);
            }
        }

        function createCrystal(x, y, z) {
            const geometry = new THREE.OctahedronGeometry(0.6);
            const material = new THREE.MeshPhongMaterial({
                color: COLORS.crystal,
                emissive: 0x444400,
                shininess: 100
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            scene.add(mesh);
            crystals.push(mesh);
        }

        function spawnNextPlatform() {
            frames++;
            let isX = Math.random() > 0.5;

            // Force straight path for first 15 blocks to align with initial ball direction
            if (platforms.length < 15) {
                isX = true;
            }

            const newX = lastPlatformPos.x + (isX ? PLATFORM_SIZE : 0);
            const newZ = lastPlatformPos.z + (isX ? 0 : -PLATFORM_SIZE); // Move -Z (forward/right visually)

            createPlatform(newX, lastPlatformPos.y, newZ);
        }

        function handleInput() {
            if (gameState === 'OVER') return;

            if (gameState === 'START') {
                gameState = 'PLAYING';
                document.getElementById('instructions').style.opacity = 0;
            } else {
                direction = direction === 'x' ? 'z' : 'x';
                playSound('switch');
            }
        }

        function gameOver() {
            gameState = 'OVER';
            playSound('gameover');
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        function restartGame() {
            location.reload();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'PLAYING') {
                // Move Ball
                const moveSpeed = speed;
                if (direction === 'x') ball.position.x += moveSpeed;
                else ball.position.z -= moveSpeed;

                // Speed up slightly over time
                speed += 0.00005;

                // Update Camera Target
                targetCameraPos.x = ball.position.x + CAMERA_OFFSET.x;
                targetCameraPos.z = ball.position.z + CAMERA_OFFSET.z;

                // Camera Follow (Smooth)
                camera.position.x += (targetCameraPos.x - camera.position.x) * 0.1;
                camera.position.z += (targetCameraPos.z - camera.position.z) * 0.1;

                // Cloud movement
                clouds.forEach(c => {
                    c.mesh.position.x += c.speed;
                    if (c.mesh.position.x > ball.position.x + 60) c.mesh.position.x = ball.position.x - 60;
                });

                // Lerp platform colors back
                platforms.forEach(p => {
                    if (p.userData.highlighted) {
                        p.material.color.lerp(new THREE.Color(COLORS.platform), 0.05);
                    }
                });

                // Collision Detection (Fall off)
                const forgivingTolerance = PLATFORM_SIZE / 2 + BALL_RADIUS * 0.4;
                const currentPlatform = platforms.find(p =>
                    Math.abs(p.position.x - ball.position.x) < forgivingTolerance &&
                    Math.abs(p.position.z - ball.position.z) < forgivingTolerance
                );

                if (!currentPlatform) {
                    // Fall logic
                    ball.position.y -= 0.5;
                    ball.position.x += (direction === 'x' ? moveSpeed : 0);
                    ball.position.z -= (direction === 'z' ? moveSpeed : 0);
                    if (ball.position.y < -10) {
                        gameOver();
                    }
                } else {
                    // Highlight platform
                    currentPlatform.material.color.setHex(COLORS.platformHighlight);
                    currentPlatform.userData.highlighted = true;
                    // Check Crystals
                    for (let i = crystals.length - 1; i >= 0; i--) {
                        const c = crystals[i];
                        const dx = c.position.x - ball.position.x;
                        const dz = c.position.z - ball.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 1) {
                            scene.remove(c);
                            crystals.splice(i, 1);
                            score += 2; // Bonus points
                            playSound('crystal');
                            document.getElementById('score').textContent = score;
                            window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');
                        } else {
                            // Rotate crystal
                            c.rotation.y += 0.05;
                            c.position.y = (currentPlatform.position.y + PLATFORM_SIZE / 2 + 1) + Math.sin(Date.now() * 0.005) * 0.2;
                        }
                    }

                    // Score calculation based on distance/platforms
                    // Just count distance? Or platforms passed?
                    // Let's increment score when passing platforms
                    if (!currentPlatform.userData.passed) {
                        currentPlatform.userData.passed = true;
                        score++;
                        document.getElementById('score').textContent = score;
                        window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');

                        // Spawn new path
                        spawnNextPlatform();
                    }
                }

                // Cleanup old platforms
                if (platforms.length > 50) {
                    const oldP = platforms.shift();
                    scene.remove(oldP);
                    if (oldP.userData.shadow) scene.remove(oldP.userData.shadow);
                }
            } else if (gameState === 'OVER') {
                clouds.forEach(c => c.mesh.position.x += c.speed);

                // Fall animation continue
                if (ball.position.y > -50) {
                    ball.position.y -= 0.5;
                    // Camera looks down slightly to watch fall
                    camera.position.y += (CAMERA_OFFSET.y + 10 - camera.position.y) * 0.05;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
    <!-- Google Ads Container -->
    <div id="ad-container"
        style="position: absolute; bottom: 0; left: 0; width: 100%; text-align: center; z-index: 100;">
        <script async
            src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX"
            crossorigin="anonymous"></script>
        <!-- Horizontal Banner -->
        <ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px"
            data-ad-client="ca-pub-XXXXXXXXXXXXXXXX" data-ad-slot="XXXXXXXXXX"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </div>
</body>

</html>