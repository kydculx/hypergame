<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Breakout - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: white;
            font-family: sans-serif;
            user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        #score {
            font-size: 36px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
            color: #333;
        }

        button {
            background: #ff00ff;
            border: none;
            padding: 15px 40px;
            color: white;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #cc00cc;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>SCORE: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (!this.ctx) {
                    try {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) this.ctx = new AudioContextClass();
                    } catch (e) { }
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            }
            playNote(freq, type, duration, volume) {
                this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                if (Array.isArray(freq)) {
                    osc.frequency.setValueAtTime(freq[0], this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq[1], this.ctx.currentTime + duration);
                } else {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                }
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let PADDLE_WIDTH = 120, PADDLE_HEIGHT = 15, BALL_RADIUS = 8, BRICK_ROWS = 8, BRICK_COLS = 10, BRICK_PADDING = 5, BRICK_OFFSET_TOP = 100, PADDLE_OFFSET_BOTTOM = 100;
        const BRICK_COLORS = ['#f43f5e', '#ec4899', '#d946ef', '#a855f7', '#6366f1', '#3b82f6', '#0ea5e9', '#06b6d4'];
        let score = 0, isGameOver = false, isStarted = false, paddleX = 0, balls = [], bricks = [], particles = [], items = [], level = 1, combo = 0, shake = 0;

        function init() {
            resize();
            initBricks();
            resetBall();
            animate();
            window.parent.postMessage({ type: 'GAME_READY' }, '*');
        }

        function initBricks() {
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            for (let c = 0; c < BRICK_COLS; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROWS; r++) {
                    bricks[c][r] = { status: 1, color: BRICK_COLORS[r % BRICK_COLORS.length] };
                }
            }
        }

        function resetBall() {
            const speed = 4 + (level * 0.5);
            balls = [{ x: canvas.width / 2, y: canvas.height - PADDLE_OFFSET_BOTTOM - 50, dx: speed * 0.7, dy: -speed * 0.7 }];
        }

        function handleAction(e) {
            audio.init();
            if (isGameOver) return;
            if (!isStarted) { isStarted = true; return; }
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            if (clientX !== undefined) {
                paddleX = clientX - PADDLE_WIDTH / 2;
                paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, paddleX));
            }
        }

        function update() {
            if (!isStarted || isGameOver) return;
            const speedScale = 4 + (level * 0.5);
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            const brickHeight = 20;

            for (let i = balls.length - 1; i >= 0; i--) {
                let b = balls[i];
                b.x += b.dx; b.y += b.dy;
                if (b.x < BALL_RADIUS || b.x > canvas.width - BALL_RADIUS) { b.dx *= -1; audio.playNote(300, 'sine', 0.05, 0.2); }
                if (b.y < BALL_RADIUS) { b.dy *= -1; audio.playNote(300, 'sine', 0.05, 0.2); }
                else if (b.y > canvas.height - BALL_RADIUS - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM) {
                    if (b.x > paddleX && b.x < paddleX + PADDLE_WIDTH && b.dy > 0) {
                        let hit = (b.x - (paddleX + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2);
                        b.dx = speedScale * Math.sin(hit * Math.PI / 3);
                        b.dy = -speedScale * Math.cos(hit * Math.PI / 3);
                        audio.playNote(200, 'square', 0.1, 0.3);
                        combo = 0;
                    } else if (b.y > canvas.height) { balls.splice(i, 1); continue; }
                }

                for (let c = 0; c < BRICK_COLS; c++) {
                    for (let r = 0; r < BRICK_ROWS; r++) {
                        let br = bricks[c][r];
                        if (br.status === 1) {
                            let bx = c * (brickWidth + BRICK_PADDING) + BRICK_PADDING;
                            let by = r * (brickHeight + BRICK_PADDING) + BRICK_OFFSET_TOP;
                            if (b.x > bx && b.x < bx + brickWidth && b.y > by && b.y < by + brickHeight) {
                                b.dy *= -1; br.status = 0; score += ++combo;
                                document.getElementById('score').textContent = score;
                                audio.playNote(400 + r * 50, 'triangle', 0.1, 0.2);
                                if (Math.random() < 0.1) items.push({ x: bx + brickWidth / 2, y: by, type: Math.random() < 0.5 ? 'WIDE' : 'MULTI' });
                                window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');
                                if (bricks.flat().every(nb => nb.status === 0)) { level++; initBricks(); resetBall(); }
                            }
                        }
                    }
                }
            }
            if (balls.length === 0) gameOver();
            items.forEach((it, idx) => {
                it.y += 2;
                if (it.y > canvas.height - PADDLE_OFFSET_BOTTOM - PADDLE_HEIGHT && it.x > paddleX && it.x < paddleX + PADDLE_WIDTH) {
                    if (it.type === 'WIDE') { PADDLE_WIDTH = 200; setTimeout(() => PADDLE_WIDTH = 120, 5000); }
                    else balls.push({ ...balls[0], dx: -balls[0].dx });
                    items.splice(idx, 1);
                }
            });
        }

        function render() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0ff'; ctx.fillRect(paddleX, canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM, PADDLE_WIDTH, PADDLE_HEIGHT);
            balls.forEach(b => { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2); ctx.fill(); });
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            bricks.forEach((col, c) => col.forEach((br, r) => {
                if (br.status === 1) {
                    ctx.fillStyle = br.color;
                    ctx.fillRect(c * (brickWidth + BRICK_PADDING) + BRICK_PADDING, r * 25 + BRICK_OFFSET_TOP, brickWidth, 20);
                }
            }));
            items.forEach(it => { ctx.fillStyle = it.type === 'WIDE' ? '#0f0' : '#0af'; ctx.fillRect(it.x, it.y, 20, 20); });
        }

        function animate() { requestAnimationFrame(animate); update(); render(); }
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; paddleX = (canvas.width - PADDLE_WIDTH) / 2; }
        function gameOver() {
            if (isGameOver) return; isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            audio.playNote([220, 50], 'sawtooth', 0.5, 0.4);
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        window.addEventListener('mousemove', handleAction);
        window.addEventListener('touchmove', handleAction);
        window.addEventListener('mousedown', handleAction);
        window.addEventListener('resize', resize);
        init();
    </script>
</body>

</html>