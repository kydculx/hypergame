<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Breakout - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        #score {
            font-size: 36px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        button {
            background: #ff00ff;
            border: none;
            padding: 15px 30px;
            color: white;
            font-family: inherit;
            font-size: 20px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 10px #ff00ff;
        }

        button:hover {
            background: #d400d4;
            box-shadow: 0 0 20px #ff00ff;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1 style="color: #00ffff; margin-top: 0;">GAME OVER</h1>
        <p>SCORE: <span id="final-score" style="color: #ff00ff;">0</span></p>
        <button onclick="location.reload()">START</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');

        // Audio Manager
        class AudioManager {
            constructor() { this.ctx = null; }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
            }

            playNote(freq, type, duration, volume) {
                if (!this.ctx) return;

                // Try resume if suspended (though init should handle it)
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(() => { });
                    return; // Skip this note if not ready
                }

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                if (Array.isArray(freq)) {
                    osc.frequency.setValueAtTime(freq[0], this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq[1], this.ctx.currentTime + duration);
                } else {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                }
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        // Game Constants
        let PADDLE_WIDTH = 120;
        let targetPaddleWidth = 120; // New: for smooth transition
        const PADDLE_HEIGHT = 15;
        const BALL_RADIUS = 8;
        const BRICK_ROWS = 8;
        const BRICK_COLS = 10;
        const BRICK_PADDING = 5;
        const BRICK_OFFSET_TOP = 100;
        const BRICK_COLORS = ['#f43f5e', '#ec4899', '#d946ef', '#a855f7', '#6366f1', '#3b82f6', '#0ea5e9', '#06b6d4'];
        const PADDLE_OFFSET_BOTTOM = 100;

        let score = 0;
        let isGameOver = false;
        let isStarted = false;
        let paddleX = 0;
        let balls = []; // Changed from single variables to array
        let bricks = [];
        let particles = [];
        let items = [];
        let level = 1;
        let lives = 3;
        let combo = 0;
        let shake = 0;
        let glowPulse = 0; // New: for brick animation

        // Brick Patterns (1: brick, 0: empty)
        const patterns = [
            // Level 1: Standard Grid
            null,
            // Level 2: Heart
            [
                [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]
            ],
            // Level 3: Diamond
            [
                [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]
            ],
            // Level 4: Space Invader
            [
                [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                [0, 0, 0, 1, 1, 0, 1, 1, 0, 0]
            ],
            // Level 5: X Pattern
            [
                [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
                [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
                [1, 1, 0, 0, 0, 0, 0, 0, 1, 1]
            ],
            // Level 6: Pillars
            [
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
            ],
            // Level 7: Smiley
            [
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ],
            // Level 8: Pyramid
            [
                [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]
            ],
            // Level 9: Castle
            [
                [1, 0, 1, 0, 1, 1, 0, 1, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Level 10: Maze
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        ];

        function initBricks() {
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            // Use modulo to cycle through patterns safely
            const patternIndex = (level - 1) % patterns.length;
            const currentPattern = patterns[patternIndex];

            for (let c = 0; c < BRICK_COLS; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROWS; r++) {
                    let status = 1;
                    if (currentPattern) {
                        if (currentPattern[r] && currentPattern[r][c] === 0) status = 0;
                    }
                    bricks[c][r] = { x: 0, y: 0, status: status, color: BRICK_COLORS[r % BRICK_COLORS.length] };
                }
            }
        }

        function spawnItem(x, y) {
            const rand = Math.random();
            if (rand < 0.10) { // 10% WIDE
                items.push({ x, y, w: 30, h: 20, vy: 2, type: 'WIDE' });
            } else if (rand < 0.15) { // 5% MULTI (New)
                items.push({ x, y, w: 30, h: 20, vy: 2, type: 'MULTI' });
            }
        }

        function resetBall() {
            // Constant speed reset with correct magnitude
            const speed = 4 + (level * 0.5);
            const angle = Math.PI / 4; // 45 degrees
            balls = [{
                x: canvas.width / 2,
                y: canvas.height - PADDLE_OFFSET_BOTTOM - PADDLE_HEIGHT - 50,
                dx: speed * Math.sin(angle),
                dy: -speed * Math.cos(angle)
            }];
        }

        /* Removed normalizeVelocity function */

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            paddleX = (canvas.width - PADDLE_WIDTH) / 2;
            initBricks();
            resetBall();
        }
        window.addEventListener('resize', resize);

        function handleAction(e) {
            audio.init();
            if (isGameOver) return;
            if (!isStarted) {
                isStarted = true;
                return;
            }
            if (e.type === 'mousemove' || e.type === 'touchmove') {
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                paddleX = clientX - PADDLE_WIDTH / 2;
                if (paddleX < 0) paddleX = 0;
                if (paddleX > canvas.width - PADDLE_WIDTH) paddleX = canvas.width - PADDLE_WIDTH;
            }
        }

        window.addEventListener('mousemove', handleAction);
        window.addEventListener('touchmove', handleAction);
        window.addEventListener('mousedown', handleAction);

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color
                });
            }
        }

        function checkLevelComplete() {
            for (let c = 0; c < BRICK_COLS; c++) {
                for (let r = 0; r < BRICK_ROWS; r++) {
                    if (bricks[c][r].status === 1) {
                        return false;
                    }
                }
            }
            return true;
        }

        function collisionDetection() {
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            const brickHeight = 20;

            for (let i = 0; i < balls.length; i++) {
                let ball = balls[i];
                for (let c = 0; c < BRICK_COLS; c++) {
                    for (let r = 0; r < BRICK_ROWS; r++) {
                        let b = bricks[c][r];
                        if (b.status === 1) {
                            const bx = c * (brickWidth + BRICK_PADDING) + BRICK_PADDING;
                            const by = r * (brickHeight + BRICK_PADDING) + BRICK_OFFSET_TOP;

                            const distX = Math.abs(ball.x - (bx + brickWidth / 2));
                            const distY = Math.abs(ball.y - (by + brickHeight / 2));

                            if (distX > (brickWidth / 2 + BALL_RADIUS)) continue;
                            if (distY > (brickHeight / 2 + BALL_RADIUS)) continue;

                            if (distX <= (brickWidth / 2) || distY <= (brickHeight / 2) ||
                                (distX - brickWidth / 2) ** 2 + (distY - brickHeight / 2) ** 2 <= (BALL_RADIUS ** 2)) {

                                const overlapX = (brickWidth / 2 + BALL_RADIUS) - distX;
                                const overlapY = (brickHeight / 2 + BALL_RADIUS) - distY;

                                if (overlapX < overlapY) {
                                    ball.dx = -ball.dx;
                                    ball.x += (ball.dx > 0 ? overlapX : -overlapX);
                                } else {
                                    ball.dy = -ball.dy;
                                    ball.y += (ball.dy > 0 ? overlapY : -overlapY);
                                }

                                // Re-normalize after collision to be safe
                                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                                ball.dx = (ball.dx / speed) * (4 + (level * 0.5));
                                ball.dy = (ball.dy / speed) * (4 + (level * 0.5));

                                b.status = 0;
                                combo++;
                                score += combo; // Bonus points for combo
                                shake = 5; // Reduced shake for bricks
                                scoreEl.textContent = score;
                                createParticles(bx + brickWidth / 2, by + brickHeight / 2, b.color);
                                spawnItem(bx + brickWidth / 2, by + brickHeight / 2);
                                audio.playNote(400 + (r * 100), 'triangle', 0.1, 0.1);
                                window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');

                                if (checkLevelComplete()) {
                                    level++;
                                    const speedMultiplier = 1.2;

                                    ctx.fillStyle = 'white';
                                    ctx.font = '40px monospace';
                                    ctx.fillText('LEVEL ' + level, canvas.width / 2 - 80, canvas.height / 2);

                                    resetBall();
                                    // Apply speed multiplier to the new ball
                                    if (balls.length > 0) {
                                        balls[0].dx *= Math.pow(speedMultiplier, level - 1);
                                        balls[0].dy *= Math.pow(speedMultiplier, level - 1);
                                    }

                                    initBricks();
                                    isStarted = false;
                                    return; // Stop processing collision for this frame
                                }
                            }
                        }
                    }
                }
            }
        }

        function update() {
            if (isGameOver || !isStarted) return;

            // Smooth Paddle Resize
            if (Math.abs(PADDLE_WIDTH - targetPaddleWidth) > 0.1) {
                const prevWidth = PADDLE_WIDTH;
                PADDLE_WIDTH += (targetPaddleWidth - PADDLE_WIDTH) * 0.15; // ~0.3s transition
                // Keep center position: shift X by half of width change
                paddleX -= (PADDLE_WIDTH - prevWidth) / 2;
            } else {
                PADDLE_WIDTH = targetPaddleWidth;
            }

            // Update all balls
            const currentLevelSpeed = 4 + (level * 0.5); // Baseline speed

            for (let i = balls.length - 1; i >= 0; i--) {
                let ball = balls[i];

                // Enforce constant speed magnitude
                // This fixes the 'laggy' speed issue by normalizing every frame
                const currentMag = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                if (currentMag !== 0) {
                    ball.dx = (ball.dx / currentMag) * currentLevelSpeed;
                    ball.dy = (ball.dy / currentMag) * currentLevelSpeed;
                }

                // Wall collisions
                if (ball.x + ball.dx > canvas.width - BALL_RADIUS || ball.x + ball.dx < BALL_RADIUS) {
                    ball.dx = -ball.dx;
                    audio.playNote(300, 'sine', 0.05, 0.05);
                }
                if (ball.y + ball.dy < BALL_RADIUS) {
                    ball.dy = -ball.dy;
                    audio.playNote(300, 'sine', 0.05, 0.05);
                } else if (ball.y + ball.dy > canvas.height - BALL_RADIUS - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM) {
                    // Paddle Check
                    if (ball.y < canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM && ball.dy > 0 &&
                        ball.x + BALL_RADIUS > paddleX && ball.x - BALL_RADIUS < paddleX + PADDLE_WIDTH) {

                        // Calculate hit position (-1 to 1)
                        let hitPos = (ball.x - (paddleX + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2);

                        // Bounce angle based on hit position (max 60 degrees)
                        const maxBounceAngle = Math.PI / 3;
                        const theta = hitPos * maxBounceAngle;

                        // New velocity based on fixed speed
                        ball.dx = currentLevelSpeed * Math.sin(theta);
                        ball.dy = -currentLevelSpeed * Math.cos(theta);

                        // Prevent stuck
                        ball.y = canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM - BALL_RADIUS - 1;
                        combo = 0;
                        audio.playNote(200, 'square', 0.1, 0.1);
                    } else if (ball.y + ball.dy > canvas.height - BALL_RADIUS) {
                        // Ball lost
                        balls.splice(i, 1);
                        continue;
                    }
                }

                ball.x += ball.dx;
                ball.y += ball.dy;
            }

            if (shake > 0) shake *= 0.9; // Decay shake

            // Life check
            if (balls.length === 0) {
                lives--;
                combo = 0; // Reset combo
                if (lives > 0) {
                    audio.playNote([150, 100], 'sawtooth', 0.3, 0.2);
                    resetBall();
                    isStarted = false;
                } else {
                    gameOver();
                }
            }

            collisionDetection();

            // Item update
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.y += item.vy;

                // Collect Item
                if (item.y + item.h > canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM &&
                    item.x < paddleX + PADDLE_WIDTH &&
                    item.x + item.w > paddleX) {

                    if (item.type === 'WIDE') {
                        targetPaddleWidth = 200;
                        setTimeout(() => { targetPaddleWidth = 120; }, 8000);
                        audio.playNote(600, 'sine', 0.3, 0.2);
                    } else if (item.type === 'MULTI') {
                        const currentCount = balls.length;
                        for (let j = 0; j < currentCount; j++) {
                            // Duplicate ball with slightly different angle
                            let b = balls[j];
                            balls.push({
                                x: b.x, y: b.y,
                                dx: -b.dx, dy: b.dy // Reverse horizontal direction for new ball
                            });
                        }
                        audio.playNote([400, 800], 'square', 0.3, 0.2);
                    }
                    items.splice(i, 1);
                } else if (item.y > canvas.height) {
                    items.splice(i, 1);
                }
            }

            // Particle update
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake
            if (shake > 0.5) {
                const sx = (Math.random() - 0.5) * shake;
                const sy = (Math.random() - 0.5) * shake;
                ctx.translate(sx, sy);
            }

            // UI Elements (Level & Lives)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('LEVEL: ' + level, 20, 30);

            if (combo > 1) {
                ctx.fillStyle = '#ffff00';
                ctx.fillText('COMBO X' + combo, 20, 60);
            }

            ctx.textAlign = 'right';
            let livesStr = '';
            for (let i = 0; i < lives; i++) livesStr += 'â™¥';
            ctx.fillStyle = '#ff00ff';
            ctx.fillText('LIVES: ' + livesStr, canvas.width - 20, 30);

            // Bricks
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            const brickHeight = 20; // Matches collision logic

            glowPulse = (Math.sin(Date.now() / 200) + 1) / 2; // 0 to 1

            ctx.shadowBlur = 0; // Reset for performance

            for (let c = 0; c < BRICK_COLS; c++) {
                for (let r = 0; r < BRICK_ROWS; r++) {
                    if (bricks[c][r].status === 1) {
                        const bx = c * (brickWidth + BRICK_PADDING) + BRICK_PADDING;
                        const by = r * (brickHeight + BRICK_PADDING) + BRICK_OFFSET_TOP;
                        ctx.strokeStyle = bricks[c][r].color;
                        // Optimized shadow: only apply low blur
                        // ctx.shadowBlur = 5 + (glowPulse * 15); <--- Too heavy
                        ctx.strokeRect(bx, by, brickWidth, brickHeight);
                        ctx.fillStyle = bricks[c][r].color + '33'; // 33 is alpha
                        ctx.fillRect(bx, by, brickWidth, brickHeight);
                    }
                }
            }

            // Items
            items.forEach(item => {
                const color = item.type === 'WIDE' ? '#00ff00' : '#00aaff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.strokeStyle = color;
                ctx.strokeRect(item.x, item.y, item.w, item.h);
                ctx.fillStyle = color;
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.type, item.x + item.w / 2, item.y + item.h / 2 + 4);
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1.0;

            // Paddle
            ctx.shadowBlur = 10; // Reduced from 20
            ctx.shadowColor = '#00ffff';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(paddleX, canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM, PADDLE_WIDTH, PADDLE_HEIGHT);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.fillRect(paddleX, canvas.height - PADDLE_HEIGHT - PADDLE_OFFSET_BOTTOM, PADDLE_WIDTH, PADDLE_HEIGHT);

            // Balls
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = '#fff';
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });

            if (!isStarted) {
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'white';
                ctx.font = '24px "Courier New"';
                ctx.textAlign = 'center';
                if (level > 1) {
                    ctx.fillText('LEVEL ' + level + ' READY', canvas.width / 2, canvas.height / 2 + 50);
                    ctx.font = '16px "Courier New"';
                    ctx.fillText('CLICK TO START', canvas.width / 2, canvas.height / 2 + 80);
                } else {
                    ctx.fillText('MOVE TO INITIATE', canvas.width / 2, canvas.height / 2 + 50);
                }
            }

            requestAnimationFrame(() => {
                update();
                draw();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset translation
            });
        }

        function gameOver() {
            isGameOver = true;
            gameOverEl.style.display = 'block';
            finalScoreEl.textContent = score;
            audio.playNote([220, 50], 'sawtooth', 0.5, 0.2);
            window.parent.postMessage({ type: 'GAME_OVER', payload: { score } }, '*');
        }

        resize();
        draw();
        window.parent.postMessage({ type: 'GAME_READY' }, '*');
    </script>
</body>

</html>