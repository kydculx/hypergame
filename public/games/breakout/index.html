<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Breakout - Hyper Casual</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: none;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        #score {
            font-size: 50px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        button {
            background: #ff00ff;
            border: none;
            padding: 15px 30px;
            color: white;
            font-family: inherit;
            font-size: 20px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 10px #ff00ff;
        }

        button:hover {
            background: #d400d4;
            box-shadow: 0 0 20px #ff00ff;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">0</div>
    </div>
    <div id="game-over">
        <h1 style="color: #00ffff; margin-top: 0;">FADE OUT</h1>
        <p>SCORE: <span id="final-score" style="color: #ff00ff;">0</span></p>
        <button onclick="location.reload()">START</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');

        // Audio Manager
        class AudioManager {
            constructor() { this.ctx = null; }
            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            playNote(freq, type, duration, volume) {
                if (!this.ctx) return;
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                if (Array.isArray(freq)) {
                    osc.frequency.setValueAtTime(freq[0], this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq[1], this.ctx.currentTime + duration);
                } else {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                }
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }
        const audio = new AudioManager();

        // Game Constants
        let PADDLE_WIDTH = 120;
        const PADDLE_HEIGHT = 15;
        const BALL_RADIUS = 8;
        const BRICK_ROWS = 5;
        const BRICK_COLS = 8;
        const BRICK_PADDING = 10;
        const BRICK_OFFSET_TOP = 80;
        const BRICK_COLORS = ['#f43f5e', '#ec4899', '#d946ef', '#a855f7', '#6366f1'];

        let score = 0;
        let isGameOver = false;
        let isStarted = false;
        let paddleX = 0;
        let ballX, ballY, dx, dy;
        let bricks = [];
        let particles = [];
        let items = [];

        function initBricks() {
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            for (let c = 0; c < BRICK_COLS; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROWS; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1, color: BRICK_COLORS[r] };
                }
            }
        }

        function spawnItem(x, y) {
            if (Math.random() < 0.15) { // 15% chance
                items.push({ x, y, w: 30, h: 20, vy: 2, type: 'WIDE' });
            }
        }

        function resetBall() {
            ballX = canvas.width / 2;
            ballY = canvas.height - 50;
            dx = 4;
            dy = -4;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            paddleX = (canvas.width - PADDLE_WIDTH) / 2;
            initBricks();
            resetBall();
        }
        window.addEventListener('resize', resize);

        function handleAction(e) {
            audio.init();
            if (isGameOver) return;
            if (!isStarted) {
                isStarted = true;
                return;
            }
            if (e.type === 'mousemove' || e.type === 'touchmove') {
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                paddleX = clientX - PADDLE_WIDTH / 2;
                if (paddleX < 0) paddleX = 0;
                if (paddleX > canvas.width - PADDLE_WIDTH) paddleX = canvas.width - PADDLE_WIDTH;
            }
        }

        window.addEventListener('mousemove', handleAction);
        window.addEventListener('touchmove', handleAction);
        window.addEventListener('mousedown', handleAction);

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color
                });
            }
        }

        function collisionDetection() {
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            const brickHeight = 25;
            for (let c = 0; c < BRICK_COLS; c++) {
                for (let r = 0; r < BRICK_ROWS; r++) {
                    let b = bricks[c][r];
                    if (b.status === 1) {
                        const bx = c * (brickWidth + BRICK_PADDING) + BRICK_PADDING;
                        const by = r * (brickHeight + BRICK_PADDING) + BRICK_OFFSET_TOP;
                        if (ballX > bx && ballX < bx + brickWidth && ballY > by && ballY < by + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            score++;
                            scoreEl.textContent = score;
                            createParticles(bx + brickWidth / 2, by + brickHeight / 2, b.color);
                            spawnItem(bx + brickWidth / 2, by + brickHeight / 2);
                            audio.playNote(400 + (r * 100), 'triangle', 0.1, 0.1);
                            window.parent.postMessage({ type: 'SUBMIT_SCORE', payload: { score } }, '*');

                            if (score === BRICK_ROWS * BRICK_COLS) {
                                // Victory - just speed up for now
                                dy *= 1.1; dx *= 1.1;
                                initBricks();
                            }
                        }
                    }
                }
            }
        }

        function update() {
            if (isGameOver || !isStarted) return;

            // Ball physics
            if (ballX + dx > canvas.width - BALL_RADIUS || ballX + dx < BALL_RADIUS) {
                dx = -dx;
                audio.playNote(300, 'sine', 0.05, 0.05);
            }
            if (ballY + dy < BALL_RADIUS) {
                dy = -dy;
                audio.playNote(300, 'sine', 0.05, 0.05);
            } else if (ballY + dy > canvas.height - BALL_RADIUS) {
                if (ballX > paddleX && ballX < paddleX + PADDLE_WIDTH) {
                    // Paddle Hit - change angle based on hit position
                    let hitPos = (ballX - (paddleX + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2);
                    dx = hitPos * 7;
                    dy = -dy;
                    audio.playNote(200, 'square', 0.1, 0.1);
                } else {
                    gameOver();
                }
            }

            ballX += dx;
            ballY += dy;

            collisionDetection();

            // Item update
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.y += item.vy;

                // Collect Item
                if (item.y + item.h > canvas.height - PADDLE_HEIGHT - 10 &&
                    item.x < paddleX + PADDLE_WIDTH &&
                    item.x + item.w > paddleX) {

                    if (item.type === 'WIDE') {
                        PADDLE_WIDTH = 200;
                        setTimeout(() => { PADDLE_WIDTH = 120; }, 8000);
                        audio.playNote(600, 'sine', 0.3, 0.2);
                    }
                    items.splice(i, 1);
                } else if (item.y > canvas.height) {
                    items.splice(i, 1);
                }
            }

            // Particle update
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Bricks
            const brickWidth = (canvas.width - (BRICK_COLS + 1) * BRICK_PADDING) / BRICK_COLS;
            const brickHeight = 25;
            ctx.shadowBlur = 10;
            for (let c = 0; c < BRICK_COLS; c++) {
                for (let r = 0; r < BRICK_ROWS; r++) {
                    if (bricks[c][r].status === 1) {
                        const bx = c * (brickWidth + BRICK_PADDING) + BRICK_PADDING;
                        const by = r * (brickHeight + BRICK_PADDING) + BRICK_OFFSET_TOP;
                        ctx.strokeStyle = bricks[c][r].color;
                        ctx.shadowColor = bricks[c][r].color;
                        ctx.strokeRect(bx, by, brickWidth, brickHeight);
                        ctx.fillStyle = bricks[c][r].color + '22'; // 22 is alpha
                        ctx.fillRect(bx, by, brickWidth, brickHeight);
                    }
                }
            }

            // Items
            items.forEach(item => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(item.x, item.y, item.w, item.h);
                ctx.fillStyle = '#00ff00';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('WIDE', item.x + item.w / 2, item.y + item.h / 2 + 4);
            });

            // Paddle
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(paddleX, canvas.height - PADDLE_HEIGHT - 10, PADDLE_WIDTH, PADDLE_HEIGHT);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.fillRect(paddleX, canvas.height - PADDLE_HEIGHT - 10, PADDLE_WIDTH, PADDLE_HEIGHT);


            // Ball
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1.0;

            if (!isStarted) {
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'white';
                ctx.font = '24px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('MOVE TO INITIATE', canvas.width / 2, canvas.height / 2 + 50);
            }

            requestAnimationFrame(() => {
                update();
                draw();
            });
        }

        function gameOver() {
            isGameOver = true;
            gameOverEl.style.display = 'block';
            finalScoreEl.textContent = score;
            audio.playNote([220, 50], 'sawtooth', 0.5, 0.2);
            window.parent.postMessage({ type: 'GAME_OVER' }, '*');
        }

        resize();
        draw();
        window.parent.postMessage({ type: 'GAME_READY' }, '*');
    </script>
</body>

</html>